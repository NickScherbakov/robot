"""
Database models for SelfEarnBot.
Stores opportunities, generated content, publish results, and learning data.
"""
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, Text, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import os
import json

Base = declarative_base()


class Opportunity(Base):
    """Opportunity found by scanners"""
    __tablename__ = 'selfbot_opportunities'
    
    id = Column(Integer, primary_key=True)
    source = Column(String(100))  # rss, freelance, content_market
    source_url = Column(String(500), nullable=True)
    title = Column(String(500))
    description = Column(Text)
    content_type = Column(String(50))  # article, code, seo, image
    estimated_revenue = Column(Float, default=0.0)
    estimated_cost = Column(Float, default=0.0)
    estimated_profit = Column(Float, default=0.0)
    profit_margin = Column(Float, default=0.0)
    opportunity_score = Column(Float, default=0.0)  # 0-1 score from brain
    requirements = Column(JSON, nullable=True)  # JSON with specific requirements
    status = Column(String(20), default='discovered')  # discovered, evaluated, selected, rejected
    created_at = Column(DateTime, default=datetime.utcnow)
    evaluated_at = Column(DateTime, nullable=True)
    
    def to_dict(self):
        return {
            'id': self.id,
            'source': self.source,
            'title': self.title,
            'description': self.description,
            'content_type': self.content_type,
            'estimated_revenue': self.estimated_revenue,
            'estimated_cost': self.estimated_cost,
            'estimated_profit': self.estimated_profit,
            'profit_margin': self.profit_margin,
            'opportunity_score': self.opportunity_score,
            'status': self.status
        }


class GeneratedContent(Base):
    """Content generated by AI"""
    __tablename__ = 'selfbot_generated_content'
    
    id = Column(Integer, primary_key=True)
    opportunity_id = Column(Integer, nullable=True)
    content_type = Column(String(50))
    title = Column(String(500))
    content = Column(Text)
    ai_provider = Column(String(20))
    tokens_used = Column(Integer, default=0)
    generation_cost = Column(Float, default=0.0)
    quality_score = Column(Float, nullable=True)  # Self-assessed quality 0-1
    status = Column(String(20), default='generated')  # generated, approved, rejected, published
    created_at = Column(DateTime, default=datetime.utcnow)
    
    def to_dict(self):
        return {
            'id': self.id,
            'opportunity_id': self.opportunity_id,
            'content_type': self.content_type,
            'title': self.title,
            'ai_provider': self.ai_provider,
            'tokens_used': self.tokens_used,
            'generation_cost': self.generation_cost,
            'quality_score': self.quality_score,
            'status': self.status
        }


class PublishResult(Base):
    """Results of publishing/submitting content"""
    __tablename__ = 'selfbot_publish_results'
    
    id = Column(Integer, primary_key=True)
    content_id = Column(Integer)
    opportunity_id = Column(Integer, nullable=True)
    platform = Column(String(100))
    platform_url = Column(String(500), nullable=True)
    status = Column(String(20))  # submitted, accepted, rejected, earning
    actual_revenue = Column(Float, default=0.0)
    actual_cost = Column(Float, default=0.0)
    actual_profit = Column(Float, default=0.0)
    roi = Column(Float, default=0.0)  # Return on Investment
    feedback = Column(Text, nullable=True)
    published_at = Column(DateTime, default=datetime.utcnow)
    completed_at = Column(DateTime, nullable=True)
    
    def to_dict(self):
        return {
            'id': self.id,
            'content_id': self.content_id,
            'opportunity_id': self.opportunity_id,
            'platform': self.platform,
            'status': self.status,
            'actual_revenue': self.actual_revenue,
            'actual_cost': self.actual_cost,
            'actual_profit': self.actual_profit,
            'roi': self.roi
        }


class LearningRecord(Base):
    """Learning data from successful/failed attempts"""
    __tablename__ = 'selfbot_learning'
    
    id = Column(Integer, primary_key=True)
    opportunity_id = Column(Integer, nullable=True)
    content_id = Column(Integer, nullable=True)
    result_id = Column(Integer, nullable=True)
    action_type = Column(String(50))  # opportunity_selection, content_generation, publishing
    success = Column(Boolean, default=False)
    profit = Column(Float, default=0.0)
    features = Column(JSON, nullable=True)  # Features that led to this result
    insights = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    def to_dict(self):
        return {
            'id': self.id,
            'action_type': self.action_type,
            'success': self.success,
            'profit': self.profit,
            'insights': self.insights
        }


class SelfBotDatabase:
    """Database connection manager for SelfBot"""
    
    def __init__(self, db_path='data/selfbot.db'):
        self.db_path = db_path
        self.engine = None
        self.Session = None
    
    def initialize(self):
        """Initialize database connection and create tables"""
        # Ensure data directory exists
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
        
        # Create engine
        self.engine = create_engine(f'sqlite:///{self.db_path}')
        
        # Create tables
        Base.metadata.create_all(self.engine)
        
        # Create session factory
        self.Session = sessionmaker(bind=self.engine)
        
        return self
    
    def get_session(self):
        """Get a new database session"""
        if not self.Session:
            self.initialize()
        return self.Session()
    
    def close(self):
        """Close database connection"""
        if self.engine:
            self.engine.dispose()
